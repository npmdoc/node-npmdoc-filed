<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/mikeal/filed#readme">filed (v0.1.0)</a>
</h1>
<h4>Simplified file library.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.filed">module filed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.filed.filed">
            function <span class="apidocSignatureSpan"></span>filed
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.filed.File">
            function <span class="apidocSignatureSpan">filed.</span>File
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">filed.</span>File.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">filed.</span>rfc822</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.filed.File">module filed.File</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.filed.File.File">
            function <span class="apidocSignatureSpan">filed.</span>File
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.filed.File.super_">
            function <span class="apidocSignatureSpan">filed.File.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.filed.File.prototype">module filed.File.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.filed.File.prototype.end">
            function <span class="apidocSignatureSpan">filed.File.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.filed.File.prototype.pipe">
            function <span class="apidocSignatureSpan">filed.File.prototype.</span>pipe
            <span class="apidocSignatureSpan">(dest, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.filed.File.prototype.write">
            function <span class="apidocSignatureSpan">filed.File.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.filed.rfc822">module filed.rfc822</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.filed.rfc822.getRFC822Date">
            function <span class="apidocSignatureSpan">filed.rfc822.</span>getRFC822Date
            <span class="apidocSignatureSpan">(oDate)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.filed" id="apidoc.module.filed">module filed</a></h1>


    <h2>
        <a href="#apidoc.element.filed.filed" id="apidoc.element.filed.filed">
        function <span class="apidocSignatureSpan"></span>filed
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filed = function (options) {
  return new File(options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.filed.File" id="apidoc.element.filed.File">
        function <span class="apidocSignatureSpan">filed.</span>File
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function File(options) {
  stream.Stream.call(this)

  this.writable = true
  this.readable = true
  this.buffers = []

  var self = this

  if (typeof options === 'string') options = {path:options}
  if (!options.index) options.index = 'index.html'
  self.writable = (typeof options.writable === "undefined") ? true : options.writable
  self.readable = (typeof options.readable === "undefined") ? true : options.readable

  self.path = options.path
  self.index = options.index

  self.on('pipe', function (src) {
    this.src = src
  })

  this.buffering = true

  this.mimetype = options.mimetype || mime.lookup(this.path.slice(this.path.lastIndexOf('.')+1))

  var stopBuffering = function () {
    self.buffering = false
    while (self.buffers.length) {
      self.emit('data', self.buffers.shift())
    }
    if (self.ended) self.emit('end')
  }

  fs.stat(options.path, function (err, stats) {

    var finish = function (err, stats) {
      self.stat = stats
      if (err &amp;&amp; err.code === 'ENOENT' &amp;&amp; !self.dest &amp;&amp; !self.src) self.src = self.path
      if (err &amp;&amp; !self.dest &amp;&amp; !self.src) return self.emit('error', err)
      if (err &amp;&amp; self.dest &amp;&amp; !self.dest.writeHead) return self.emit('error', err)

      // See if writes are disabled
      if (self.src &amp;&amp; self.src.method &amp;&amp;
          !self.writable &amp;&amp; self.dest.writeHead &amp;&amp;
          (self.src.method === 'PUT' || self.src.method === 'POST')) {
        self.dest.writeHead(405, {'content-type':'text/plain'})
        self.dest.end(self.src.method+' Not Allowed')
        return
      }

      if (!err) {
        self.etag = crypto.createHash('md5').update(stats.ino+'/'+stats.mtime+'/'+stats.size).digest("hex")
        self.lastmodified = rfc822.getRFC822Date(stats.mtime)
      }

      process.nextTick(function () {
        stopBuffering()
      })

      // 404 and 500
      if ( err &amp;&amp; self.dest &amp;&amp; self.dest.writeHead &amp;&amp; // We have an error object and dest is an HTTP response
           ( // Either we have a source and it's a GET/HEAD or we don't have a src
             (self.src &amp;&amp; (self.src.method == 'GET' || self.src.method === 'HEAD')) || (!self.src)
           )
         ) {
        if (err.code === 'ENOENT') {
          self.dest.statusCode = 404
          self.dest.end('Not Found')
        } else {
          self.dest.statusCode = 500
          self.dest.end(err.message)
        }
        return
      }

      // Source is an HTTP Server Request
      if (self.src &amp;&amp; (self.src.method === 'GET' || self.src.method === 'HEAD') &amp;&amp; self.dest) {
        if (self.dest.setHeader) {
          self.dest.setHeader('content-type', self.mimetype)
          self.dest.setHeader('etag', self.etag)
          self.dest.setHeader('last-modified', self.lastmodified)
        }

        if (self.dest.writeHead) {
          if (self.src &amp;&amp; self.src.headers) {
            if (self.src.headers['if-none-match'] === self.etag ||
                // Lazy last-modifed matching but it's faster than parsing Datetime
                self.src.headers['if-modified-since'] === self.lastmodified) {
              self.dest.statusCode = 304
              self.dest.end()
              return
            }
          }
          // We're going to return the whole file
          self.dest.statusCode = 200
          self.dest.setHeader('content-length', stats.size)
        } else {
          // Destination is not an HTTP response, GET and HEAD method are not allowed
          return
        }

        if (self.src.method !== 'HEAD') {
          fs.createReadStream(self.path).pipe(self.dest)
        }
        return
      }

      if (self.src &amp;&amp; (self.src.method === 'PUT' || self.src.method === 'POST')) {
        if (!err) {
          // TODO handle overwrite case
          return
        }
        stream.Stream.prototype.pipe.call(self, fs.createWriteStream(self.path))
        if (self.dest &amp;&amp; self.dest.writeHead) {
          self.on('end', function () {
            self.dest.statusCode = 201
            self.dest.setHeader('content-length', 0)
            self.dest.end()
          })
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.filed.File" id="apidoc.module.filed.File">module filed.File</a></h1>


    <h2>
        <a href="#apidoc.element.filed.File.File" id="apidoc.element.filed.File.File">
        function <span class="apidocSignatureSpan">filed.</span>File
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function File(options) {
  stream.Stream.call(this)

  this.writable = true
  this.readable = true
  this.buffers = []

  var self = this

  if (typeof options === 'string') options = {path:options}
  if (!options.index) options.index = 'index.html'
  self.writable = (typeof options.writable === "undefined") ? true : options.writable
  self.readable = (typeof options.readable === "undefined") ? true : options.readable

  self.path = options.path
  self.index = options.index

  self.on('pipe', function (src) {
    this.src = src
  })

  this.buffering = true

  this.mimetype = options.mimetype || mime.lookup(this.path.slice(this.path.lastIndexOf('.')+1))

  var stopBuffering = function () {
    self.buffering = false
    while (self.buffers.length) {
      self.emit('data', self.buffers.shift())
    }
    if (self.ended) self.emit('end')
  }

  fs.stat(options.path, function (err, stats) {

    var finish = function (err, stats) {
      self.stat = stats
      if (err &amp;&amp; err.code === 'ENOENT' &amp;&amp; !self.dest &amp;&amp; !self.src) self.src = self.path
      if (err &amp;&amp; !self.dest &amp;&amp; !self.src) return self.emit('error', err)
      if (err &amp;&amp; self.dest &amp;&amp; !self.dest.writeHead) return self.emit('error', err)

      // See if writes are disabled
      if (self.src &amp;&amp; self.src.method &amp;&amp;
          !self.writable &amp;&amp; self.dest.writeHead &amp;&amp;
          (self.src.method === 'PUT' || self.src.method === 'POST')) {
        self.dest.writeHead(405, {'content-type':'text/plain'})
        self.dest.end(self.src.method+' Not Allowed')
        return
      }

      if (!err) {
        self.etag = crypto.createHash('md5').update(stats.ino+'/'+stats.mtime+'/'+stats.size).digest("hex")
        self.lastmodified = rfc822.getRFC822Date(stats.mtime)
      }

      process.nextTick(function () {
        stopBuffering()
      })

      // 404 and 500
      if ( err &amp;&amp; self.dest &amp;&amp; self.dest.writeHead &amp;&amp; // We have an error object and dest is an HTTP response
           ( // Either we have a source and it's a GET/HEAD or we don't have a src
             (self.src &amp;&amp; (self.src.method == 'GET' || self.src.method === 'HEAD')) || (!self.src)
           )
         ) {
        if (err.code === 'ENOENT') {
          self.dest.statusCode = 404
          self.dest.end('Not Found')
        } else {
          self.dest.statusCode = 500
          self.dest.end(err.message)
        }
        return
      }

      // Source is an HTTP Server Request
      if (self.src &amp;&amp; (self.src.method === 'GET' || self.src.method === 'HEAD') &amp;&amp; self.dest) {
        if (self.dest.setHeader) {
          self.dest.setHeader('content-type', self.mimetype)
          self.dest.setHeader('etag', self.etag)
          self.dest.setHeader('last-modified', self.lastmodified)
        }

        if (self.dest.writeHead) {
          if (self.src &amp;&amp; self.src.headers) {
            if (self.src.headers['if-none-match'] === self.etag ||
                // Lazy last-modifed matching but it's faster than parsing Datetime
                self.src.headers['if-modified-since'] === self.lastmodified) {
              self.dest.statusCode = 304
              self.dest.end()
              return
            }
          }
          // We're going to return the whole file
          self.dest.statusCode = 200
          self.dest.setHeader('content-length', stats.size)
        } else {
          // Destination is not an HTTP response, GET and HEAD method are not allowed
          return
        }

        if (self.src.method !== 'HEAD') {
          fs.createReadStream(self.path).pipe(self.dest)
        }
        return
      }

      if (self.src &amp;&amp; (self.src.method === 'PUT' || self.src.method === 'POST')) {
        if (!err) {
          // TODO handle overwrite case
          return
        }
        stream.Stream.prototype.pipe.call(self, fs.createWriteStream(self.path))
        if (self.dest &amp;&amp; self.dest.writeHead) {
          self.on('end', function () {
            self.dest.statusCode = 201
            self.dest.setHeader('content-length', 0)
            self.dest.end()
          })
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.filed.File.super_" id="apidoc.element.filed.File.super_">
        function <span class="apidocSignatureSpan">filed.File.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.filed.File.prototype" id="apidoc.module.filed.File.prototype">module filed.File.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.filed.File.prototype.end" id="apidoc.element.filed.File.prototype.end">
        function <span class="apidocSignatureSpan">filed.File.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk) {
  if (chunk) this.write(chunk)
  if (this.buffering) {
    this.ended = true
  } else {
    this.emit('end')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Filed does a lazy stat call so you can actually open a file and begin writing to it and if the file isn't there it will just
 be created.

```javascript
var filed = require('filed');
var f = filed('/newfile')
f.write('test')
f.<span class="apidocCodeKeywordSpan">end</span>()
```

## Streaming

The returned file object is a stream so you can do standard stream stuff to it. Based on *what* you do the object it will be a read
 stream, a write stream.

So if you send data to it, it'll be a write stream.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.filed.File.prototype.pipe" id="apidoc.element.filed.File.prototype.pipe">
        function <span class="apidocSignatureSpan">filed.File.prototype.</span>pipe
        <span class="apidocSignatureSpan">(dest, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (dest, options) {
  this.dest = dest
  this.destOptions = options
  dest.emit('pipe', this)
  // stream.Stream.prototype.pipe.call(this, dest, options)
  return dest
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Streaming

The returned file object is a stream so you can do standard stream stuff to it. Based on *what* you do the object it will be a read
 stream, a write stream.

So if you send data to it, it'll be a write stream.

```javascript
fs.createReadStream.<span class="apidocCodeKeywordSpan">pipe</span>(filed('/newfile'))
```

If you pipe it to a destination it'll be a read stream.

```javascript
filed('/myfile').pipe(fs.createWriteStream('/out'))
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.filed.File.prototype.write" id="apidoc.element.filed.File.prototype.write">
        function <span class="apidocSignatureSpan">filed.File.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk, encoding) {
  if (encoding) chunk = chunk.toString(encoding)
  if (this.buffering) {
    this.buffers.push(chunk)
  } else {
    this.emit('data', chunk)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Super simple to use

Filed does a lazy stat call so you can actually open a file and begin writing to it and if the file isn't there it will just
 be created.

```javascript
var filed = require('filed');
var f = filed('/newfile')
f.<span class="apidocCodeKeywordSpan">write</span>('test')
f.end()
```

## Streaming

The returned file object is a stream so you can do standard stream stuff to it. Based on *what* you do the object it will be a read
 stream, a write stream.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.filed.rfc822" id="apidoc.module.filed.rfc822">module filed.rfc822</a></h1>


    <h2>
        <a href="#apidoc.element.filed.rfc822.getRFC822Date" id="apidoc.element.filed.rfc822.getRFC822Date">
        function <span class="apidocSignatureSpan">filed.rfc822.</span>getRFC822Date
        <span class="apidocSignatureSpan">(oDate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRFC822Date(oDate)
{
  var aMonths = new Array("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");

  var aDays = new Array( "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
  var dtm = new String();

  dtm = aDays[oDate.getDay()] + ", ";
  dtm += padWithZero(oDate.getDate()) + " ";
  dtm += aMonths[oDate.getMonth()] + " ";
  dtm += oDate.getFullYear() + " ";
  dtm += padWithZero(oDate.getHours()) + ":";
  dtm += padWithZero(oDate.getMinutes()) + ":";
  dtm += padWithZero(oDate.getSeconds()) + " " ;
  dtm += getTZOString(oDate.getTimezoneOffset());
  return dtm;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>